# Работа с Git
## Проверка наличия установленного Git

В терминале выполнить команду ```git  ---version```

Если Git установлен, появится сообщение с информацией о версии программы. Иначе будет сообщение об ошибке.

## Установка Git

[Загружаем последнюю версию Git с сайта https://git-scm.com/download](https://git-scm.com/download)

Устанавливаем с настройками по умолчанию.

## Настройка Git

После первого входа, необходимо представиться системе.

В терминале прописываем следующие команды:

```git config --global user.name``` «Ваше имя англ буквами»

```git config --global user.email``` ваша_почта@example.com

Первая команда запомнит Ваше имя в системе, вторая запомнит Ваш e-mail. Желательно указывать реальный адрес почты и имя, это упростит командную работу.

Далее необходимо инициализировать репозиторий Git, место где будут храниться файлы отслеживаемые системой контроля версий.

Для этого через терминал используем команду  `git init` с локальной ссылкой на папку, где будут храниться файлы, изменение которых необходимо будет отслеживать.

Например:
> ```git init C:\Users\%username%\Desktop\Homework#1```

Далее создаем файл в данном репозитории и добавляем его в систему контроля версий.

Для этого используем команду `git add` и далее указываем имя файла который необходимо добавить. 

Например:
> ```git add .\Homework1.md```

Минутка лайфхаков:

>*Можно использовать кнопку TAB на клавиатуре, тогда в команде `add` имя файла подтянется автоматически.*

>*Если Вы испольуете VSC, при запуске в стартовом окне "Начало работы" представится возможность выбрать папку, файлы в которой будут остлеживаться контролем версий, и затем просто прописать команду `git init` без точного указания пути к папке*

После добавления файла также необходимо использовать команду `git commit -m "Ваш комментарий"` , для того чтобы система начала отслеживать изменения в нём. Это своеобразная точка отсчета контроля версий файла, после которой появится возможность запоминать все последующие изменения файла и при необходимости возвращаться к предыдущим версиям.

Например:
>```git commit -m "Создали файл"```

Таким образом, подводя итоги в результате вышеописанных действий Вы:
1. Представились системе Git, указали своё имя и e-mail.
2. Инициализировали репозиторий в котором система будет отслеживать изменения файлов.
3. Начали контролировать версию первого файла, дальнейшие изменения в нём система будет отслеживать.

## Основные команды в Git


Вводя в терминал следующие команды, Вы сможете отслеживать изменения в файлах, возвращаться к предыдшим версиям своих файлов, искать и исправлять ошибки, откатывать изменения.
1. После изменения файла, которые вы хотите сохранить, необходимо использовать команды `git add <имя файла>` и команды `git commit -m  "комментарий"`. 

    Команды добавят текущую версию файла в историю изменений с комментарием о внесенных изменениях в файл.
    
     *ВАЖНО! Не забывайте сохранять файл перед использованием данных команд, командами ctrl+s или cmd+s (Mac)*

    Пример последовательности написания команд в терминале:

    > `git add <имя файла>` 

    > `git commit -m "Комментарий"`
2. Следующая команда `git status` покажет проиндексированные но не отслеживаемые файлы, то есть когда Вы внесли изменения в файл, сохранили его, но не выполнили команды из п.1., т.е. не "запомнили" системой новую версию.
    
    Пример того, что Вам покажет программа, при наличи подобных изменений:
    > Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
        modified:   Homework1.md

    Система сама подскажет Вам команды, в зависимости от того, что Вы хотите сделать в данной ситуации `git restore <имя файла>` для отката изменений, либо `git add <имя файла>` для сохранения и последующего `commit` этого файла.
3. Для просмотра истории изменений используйте команду `git log`, она покажет список  Ваших `commit` `ов с комментариями которые Вы указывали, а также хэш-код версий файла, с помощью него Вы сможете вернуться к необходимой версии и об этом расскажем чуть позже.

    Пример вывода данной операции:
    > commit a72a59006b28a1e42209066f0f2531a68bde9aeb
    
    >Author: Evgeniy <ugin2308@mail.ru>

    >Date:   Mon Jan 17 00:41:51 2022 +0300

    >Создан раздел Основные команды гит, добавлен п.1
4. Для просмотра разницы между текущей сохраненной но `не запомненной` и последней сохраненной `запомненной` версией файла, или `запомненной` ещё ранее через команду `commit`, можно использовать команду `git diff` с указанием хэш кода `commit` (для более ранних версий) который можно получить c помощью команды `git log` указанной в п.3. Результатом данной операции будет отображения всех изменений внесенных в файл относительно версии к сравнению.
    
    Пример написания данной команды, с использованием хэш кода из п.3
    > ```git diff a72a59```
    
    *Примечание: не обязательно брать хэш-код целиком, Git достаточно первых 4-6 символов кода для того чтобы распознать конкретную версию. Если нет необходимости сравнивать с версиями предшествующими последнему `commit` хэш-код указывать не требуется.*
5. Для просмотра одной из ранее сохраненных версий файла, можно воспользоваться командой `git checkout <хэш код commit>`. В этом случае Вы перейдете к версии файла которая была сохранена ранее, для правок или просмотра. Для того, чтобы вернуться к последней сохраненной версии файла используйте комманду `git checkout master`.
    
    Пример написания данной команды, с использованием хэг кода из п.3
    > `git checkout a72a59`
    
    Для выхода из режима просмотра
    > `git checkout master`

    Также возможно использовать комманды `git add` и `git commit` если нет необходимости возвращаться к "актуальной" версии.


 # Ветки в Git.

В Git реализована возможность создания отдельных веток проекта, места где можно работать над различными участками проекта, вносить изменения, запоминать и затем сливать эти изменения с основной веткой проекта.
Это очень удобно когда над одним файлом работают сразу несколько человек, их зоны ответственности разделены, или наоборот пересекаются между собой, и каждый может независимо от остальных участников, представить своё видение на отдельной ветке. Затем по мере необходимости соединив это с основной веткой проекта.

## Создание новой ветки

Для создания новой ветки проекта используйте команду `- git branch <new branch name>`

Для проверки своего "местоположения" используйте команду `- git branch` где симовлом `(*)` будет отмечена ветка в котрой вы сейчас находитесь.

Для перехода в другую ветку используйте команду `git checkout <branch_name>`

Так выглядит типовой лог операций при создании новой ветки с последующей проверкой своего местоположения и перемещение в дереве версий:


![P14](Primer14.jpg)

Ваши действия в новой ветке можно записывать и сохранять абсолютно также как и в основной ветке проекта. Комманды `-git add <filename>`, `git commit -m "комментарий"` выполняют те же роли, что в ветке мастер, по прежнему остается возможным контроль версий файла, команда `git log` покажет все `commit` `ы, которые были в файле c детализацией по веткам.

Лог при этом будет следующий:

![P17](Primer17.jpg)


# Функциональность.

## Удобные команды для навигации
Удобной командой для понимания того, как развивался проект и какие ветки были слиты можно с помощью команды `-git reflog`.

Также визуализировать историю версиий c разбивкой по веткам можно с помощью команды `-git log --graph`

Свёрнутая версия этой команды, на мой взгляд, более удобная для четния `-git log --graph --oneline`.

## Операции с ветками 
При работе с ветками, Вам возможно захочется принять изменения из одной веток, перенести их в основную, либо же отказаться от необходимости этих изменений, для этого Вам помогут следующие команды.

Соединить две ветки в одну можно с помощью команды `-git merge <branch_name>`. После чего система соединит текущую ветку в которой Вы находитесь, с веткой указанной в `<>`. 

Когда ветки сливаются без ошибок, записи в терминале следующие:


![P17](Primer18.jpg)

Иногда, ряд веток становится не нужным для дальнейшего контроля, соответственно их можно удалить. Для этого можно воспользоваться командой `git branch -d <branch_name`>. 

Пример последовательности данной операции Вы можете наблюдать на картинке ниже:

![P15](Primer15.jpg)

![P16](Primer16.jpg)



## Конфликтные ситуации. Реальный опыт решения и мысли в слух возникшие в процессе выполнения домашней работы.

Насколько я понял - Git подразумевает структурированную работу с документом, чтобы участки редактирования были заранее оговорены, т.к. замена больших блоков отнимает много сил на анализ расхождений. Тем не менее, из данного файла я создал две ветки, одна из которых `scrsh` а другая `konflikt`. Первой была крайняя ветка. В этой ветке я внёс исправление в текущий блок. Сохранил файл и перешел в ветку `scrsh`.

>>На самом деле веток, по ходу изучения функционала я насоздавал много, но не записывал об этом информацию, изначальные две я так и оставил в финальном проекте.

Конфликт чаще всего возникает, когда заполнение файла идет не последовательно, новые блоки не увязываются между собой, в новых ветках стирается или перезаписывается информация в смежных строках с веткой `master`, соответственно надо сохранять файл постоянно, желательно при этом всегда отслеживая где и в каком состоянии его ветки на текущий момент Вы находитесь, регулярно используйте команды `-git status`, `-git branch` чтобы не потеряться.

>*Совет от чайника*:

>Финальные версии веток через `merge` агрегируйте в ветке мастер и затем удаляйте их, т.к. внеся изменения в дельта-ветки, и сливая их между собой, можно нарваться на то, что основной ствол уйдет в дельту и вы потеряете свои `commit`ы, у меня такое случилось по ходу разбора веток несколько раз.Хорошим тоном, насколько я понял, будет являться удаление веток, которые мы слили с мастер веткой, и созание новых веток из `master` версии по мере продвижения, т.к. актуализация индексов и информации в файле крайне важна. Очень много конфликтов возникает когда "старые" версии проекта сливаются с актуальными. Старайтесь, по-возможности, ветки вести относительно крайней актуальной версии файла, это важно.

Например при добавлении ветки `scrsh` с упоряд. списком всех скринов не вызвало каких либо конфликтов при слиянии, а последующее слияние с веткой `konflikt` привело к ошибке такого рода:
>![P11](Primer11.jpg)

На выбор будет предложено либо принятие какого-то одного участка, обеих вариантов, либо сравнение их между собой.

Такой конфликт кажется не сложным, если у Вас разница в небольшом участке:
![P12](Primer12.jpg)


И гораздо сложнее на "объемных участках" проекта:

![P7](Primer8.jpg)

* > *Обратите внимание, сверху указана текущая версия HEAD и выделена зеленым цветом,Синим цветом выделено входящее изменение даннного участка файла.*

Следует добавлять все изменения последовательно, резкие правки и вставки губят.

Также верный способ избежать конфликтных ситуаций, сразу после `merge` и разрешения ситуации с конфликтом показанным выше незамедлительно сохранить файл через команды `git add` и `git commit`, иначе при переходе в другие ветки и правки в них, возникнет конфликт версионности файла.
Вот как визуально проявляется информация о том, что файл находится в состоянии конфликта:

>![P13](Primer13.jpg)


 >Не совсем понял как, но есть вероятность, что если после коммита о решенном конфликте добавлять новую информацию в `master` и делать повторный `add + commit` то новая версия не потянет за собой конфликтов.
 >>>*ушел пробовать*" 

 >> update. Работает!

Остальные конфликтые ситуации связаны с потерей версиии файла, очень важно, строго запоминать все изменения в ветках проекта `step by step`, иначе при несохраненных изменения в одной ветке, переход в другую и сохранение изменений в ней может приветси к потере данных в изначальной ветке. При слиянии также возникнут ошбики.

Но тем не менее, если Вы всё таки потерялись в версиях/ветках/слияниях, как и я в процессе создания этого файла, Вы всегда можете использовать команду `git checkout <хэш-код commit>`. После чего система перенесет Вас к определенной версии проекта, и если она Вас устраивает Вы можете создать из неё отдельную ветку в текущем проекте с помощью команды `git switch -c <new_branch_name>`, в дальнейшем соединив или заменив ею ветку `master` при слиянии.


# Скриншоты конфилктов с кратиким описанием

>От идеи со скриншотами решил отказаться. Много лишней информации, все необходимые указаны ранее

# Мысли в слух.

По итогу, мне стало ясно, что все изменения должны быть четко и последовательно фиксированы, и не стоит хранить супер древние версии веток, во избежании конфликтов при слиянии. Как можно чаще сверять своё местоположение перед сохранением изменений, актуализировать ветки относительно "рабочей" версии файла для "безболезненных `mergeй`
Старые ветки желательно удалять сразу послет того как они выполнили свою роль.
